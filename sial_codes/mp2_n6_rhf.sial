#  Copyright (c) 2003-2010 University of Florida
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  The GNU General Public License is included in this distribution
#  in the file COPYRIGHT.
      SIAL MP2_N6_RHF  
#
# Make index definitions 
#
      aoindex mu     = 1, norb 
      aoindex nu     = 1, norb 
      aoindex lambda = 1, norb 
      aoindex sigma  = 1, norb 
#
      moaindex i = baocc, eaocc
      moaindex i1= baocc, eaocc
      moaindex i2= baocc, eaocc
      moaindex i3= baocc, eaocc
#
      moaindex a = bavirt, eavirt
      moaindex a1= bavirt, eavirt
      moaindex a2= bavirt, eavirt
      moaindex a3= bavirt, eavirt 
#
      mobindex j = bbocc, ebocc
      mobindex j1= bbocc, ebocc
      mobindex j2= bbocc, ebocc
      mobindex j3= bbocc, ebocc
#
      mobindex b = bbvirt, ebvirt
      mobindex b1= bbvirt, ebvirt
      mobindex b2= bbvirt, ebvirt
      mobindex b3= bbvirt, ebvirt 
#
      moaindex p = baocc, eavirt  
      moaindex p1= baocc, eavirt  
      moaindex p2= baocc, eavirt  
      moaindex p3= baocc, eavirt  
#
      mobindex q = bbocc, ebvirt  
      mobindex q1= bbocc, ebvirt  
      mobindex q2= bbocc, ebvirt  
      mobindex q3= bbocc, ebvirt  
#
# Declare distributed arrays which are used 
# 
      distributed Vxixi(mu,i1,nu,i) 
      distributed Vaiai(a,i1,a1,i) 
      distributed Vxjxj(mu,j1,nu,j) 
      distributed Vbjbj(b,j1,b1,j) 
      distributed Vxixj(mu,i,nu,j) 
      distributed Vaibj(a,i,b,j) 
#
# Declare Temporary arrays which are used 
# 
      temp Txxxi(mu,nu,lambda,i) 
      temp Txxxj(mu,nu,lambda,j) 
      temp Txiai(mu,i,a,i1) 
      temp T1xiai(mu,i,a,i1) 
      temp Txjbj(mu,j,b,j1) 
      temp Txibj(mu,i,b,j1) 
      temp Txixi(mu,i,nu,i1) 
      temp T1xixi(mu,i,nu,i1) 
      temp Txjxj(mu,j,nu,j1) 
      temp T1xjxj(mu,j,nu,j1) 
      temp Txixj(mu,i,nu,j) 
      temp T1xixj(mu,i,nu,j) 
      temp Taiai(a,i,a1,i1) 
      temp T1aiai(a,i,a1,i1) 
      temp Tbjbj(b,j,b1,j1) 
      temp T1bjbj(b,j,b1,j1) 
      temp Taibj(a,i,b,j) 
      temp T1aibj(a,i,b,j) 
      temp V0xxxi(mu,nu,lambda,i) 
      temp V2xxxi(mu,nu,sigma,i) 
      temp V0xxxj(mu,nu,lambda,j) 
      temp V2xxxj(mu,nu,sigma,j) 
#
# Declare served arrays 
# 
      temp AOINT(mu,nu,lambda,sigma)
      temp BOINT(mu,nu,lambda,sigma)
#
# Declare Scalars 
#
     scalar etemp 
     scalar esum 
     scalar esumaa  
     scalar esumab  
     scalar esumbb  
     scalar ecorraa 
     scalar ecorrbb 
     scalar ecorrab 
     scalar mp2_energy 
#
#    ------------------------------------------------------------------------ 
#
     PROC TRAN_XXOO 
#
#    ------------------------------------------------------------------------ 
#
     execute sip_barrier 
#
     DO i 
#
        create Vxixi(*,*,*,i)
        create Vaiai(*,*,*,i)     
        execute sip_barrier 
#
        PARDO mu, nu, lambda, sigma  
#
              IF mu     < nu
              IF lambda < sigma
#
                 compute_integrals        AOINT(mu,nu,lambda,sigma)
                 V0xxxi(mu,nu,lambda,i) = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                 V2xxxi(mu,nu,sigma,i)  = AOINT(mu,nu,lambda,sigma)*ca(lambda,i)
#
                 DO i1 
#
                    Txixi(mu,i1,lambda,i)      = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                    put Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                    T1xixi(mu,i1,sigma,i)      = V2xxxi(mu,nu,sigma,i)*ca(nu,i1)
                    put Vxixi(mu,i1,sigma,i)  += T1xixi(mu,i1,sigma,i)
#
                 ENDDO i1  
#
                 DO i1
#
                    Txixi(nu,i1,lambda,i)      = V0xxxi(mu,nu,lambda,i)*ca(mu,i1)
                    put Vxixi(nu,i1,lambda,i) += Txixi(nu,i1,lambda,i)
#
                    T1xixi(nu,i1,sigma,i)      = V2xxxi(mu,nu,sigma,i)*ca(mu,i1)
                    put Vxixi(nu,i1,sigma,i)  += T1xixi(nu,i1,sigma,i)
#
                 ENDDO i1
#
              ENDIF # lambda < sigma
              ENDIF # mu     < nu
#
        ENDPARDO mu, nu, lambda, sigma  
#
        PARDO mu, nu, lambda, sigma  
#
              IF mu     == nu
              IF lambda < sigma
#
                 compute_integrals        AOINT(mu,nu,lambda,sigma)
                 V0xxxi(mu,nu,lambda,i) = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
                 V2xxxi(mu,nu,sigma,i)  = AOINT(mu,nu,lambda,sigma)*ca(lambda,i)
#
                 DO i1 
#
                    Txixi(mu,i1,lambda,i)      = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                    put Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                    T1xixi(mu,i1,sigma,i)      = V2xxxi(mu,nu,sigma,i)*ca(nu,i1)
                    put Vxixi(mu,i1,sigma,i)  += T1xixi(mu,i1,sigma,i)
#
                 ENDDO i1  
#
              ENDIF # lambda < sigma
              ENDIF # mu     == nu
#
        ENDPARDO mu, nu, lambda, sigma  
#
        PARDO mu, nu, lambda, sigma  
#
              IF mu     < nu
              IF lambda == sigma
#
                 compute_integrals        AOINT(mu,nu,lambda,sigma)
                 V0xxxi(mu,nu,lambda,i) = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
#
                 DO i1 
#
                    Txixi(mu,i1,lambda,i)      = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                    put Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                    T1xixi(nu,i1,lambda,i)     = V0xxxi(mu,nu,lambda,i)*ca(mu,i1)
                    put Vxixi(nu,i1,lambda,i) += T1xixi(nu,i1,lambda,i)
#
                 ENDDO i1
#
              ENDIF # lambda == sigma
              ENDIF # mu     < nu
#
        ENDPARDO mu, nu, lambda, sigma  
#
        PARDO mu, nu, lambda, sigma  
#
              IF mu     == nu
              IF lambda == sigma
#
                 compute_integrals        AOINT(mu,nu,lambda,sigma)
                 V0xxxi(mu,nu,lambda,i) = AOINT(mu,nu,lambda,sigma)*ca(sigma,i)
#
                 DO i1 
#
                    Txixi(mu,i1,lambda,i)      = V0xxxi(mu,nu,lambda,i)*ca(nu,i1)
                    put Vxixi(mu,i1,lambda,i) += Txixi(mu,i1,lambda,i)
#
                 ENDDO i1  
#
              ENDIF # lambda == sigma
              ENDIF # mu     == nu
#
        ENDPARDO mu, nu, lambda, sigma  
#       
        execute sip_barrier 
#
        PARDO a1, mu, i1  
#
           Txiai(mu,i1,a1,i) = 0.0 
#
           DO lambda  
#
              get                  Vxixi(mu,i1,lambda,i)
              T1xiai(mu,i1,a1,i) = Vxixi(mu,i1,lambda,i)*ca(lambda,a1)  
              Txiai(mu,i1,a1,i) += T1xiai(mu,i1,a1,i) 
#
           ENDDO lambda  
#
           DO a 
#
              Taiai(a,i1,a1,i)      = Txiai(mu,i1,a1,i)*ca(mu,a) 
              put Vaiai(a,i1,a1,i) += Taiai(a,i1,a1,i)  
#
           ENDDO a 
#
        ENDPARDO a1, mu, i1  
#
        execute sip_barrier 
        delete Vxixi(*,*,*,i)
#
        PARDO a, a1, i1   
#
              get                        Vaiai(a,i1,a1,i)  
              get                        Vaiai(a1,i1,a,i)  
              Taiai(a,i1,a1,i)         = Vaiai(a,i1,a1,i)
              T1aiai(a,i1,a1,i)        = Vaiai(a1,i1,a,i)
              Taiai(a,i1,a1,i)        *= 2.0  
              Taiai(a,i1,a1,i)        -= T1aiai(a,i1,a1,i)  
              execute energy_denominator Taiai  
              etemp                    = Taiai(a,i1,a1,i)*Vaiai(a,i1,a1,i) 
             #etemp                   *= 0.25  
              esumaa                  += etemp 
#
        ENDPARDO a, a1, i1   
#
        execute sip_barrier 
        delete Vaiai(*,*,*,i)
#
     ENDDO i
#
#    ------------------------------------------------------------------------ 
#
     ENDPROC TRAN_XXOO 
# 
#    ------------------------------------------------------------------------ 
# 
     PROC MP2_RHF 
# 
     execute sip_barrier
     collective ecorraa += esumaa  
     execute sip_barrier

     execute print_scalar ecorraa 
#
     mp2_energy  = ecorraa 
     totenerg   = mp2_energy + scfeneg
     execute print_scalar mp2_energy  
# 
#    ------------------------------------------------------------------------ 
# 
     ENDPROC MP2_RHF 
# 
#    ------------------------------------------------------------------------ 
#
# ************************************************************************* 
#
#    Main program which performs a two-electron transformation and then
#    a second-order energy calculation. 
#
# ************************************************************************* 
# 
     CALL TRAN_XXOO
#
     CALL MP2_RHF
# 
     execute sip_barrier totenerg
     ENDSIAL MP2_N6_RHF  
#
